# Technical Implementation Plan: Safe AI Editing Improvements

This plan turns the high-level stabilization goals in `fixing_ai.md` into actionable workstreams with trackable tasks.

## Workstream A — Snapshot Integrity Guardrails
- [ ] **Bridge contract update**: Patch the existing bridge in `src/tinkerbell/services/bridge.py` (wired through `WorkspaceBridgeRouter`) to treat `document_version`/`content_hash` as mandatory, compare them to the active `DocumentState`, and continue using/renaming `DocumentVersionMismatchError` instead of inventing a second exception. Reject range patches whenever either the supplied `match_text` **or** `content_hash`/`chunk_hash` disagree with the live document so we never “best effort” corrupted edits, and bubble the error through the router so tab-aware callers get the right `tab_id` plus an `edit_rejected` telemetry payload.
- [ ] **Tool propagation**: Ensure every code path that can enqueue edits (not just `DocumentEditTool`/`DocumentApplyPatchTool`, but also helpers like `SearchReplaceTool`) carries both `document_version` and `content_hash` from the freshest snapshot, converts inline directives into diff/patch payloads, and drops legacy inline actions entirely so the bridge only ever receives guarded patch traffic.
- [ ] **Agent retry path**: Teach the controller (`src/tinkerbell/ai/orchestration/controller.py`) to catch `DocumentVersionMismatchError`, force a new `document_snapshot`, rebuild the diff once, and raise a structured warning/telemetry record on the second failure so the operator sees why the edit was dropped.
- [ ] **Telemetry**: Reuse the existing `patch.apply` event (adding tab metadata + cause codes inside `WorkspaceBridgeRouter`) and emit a sibling `edit_rejected` event whenever the bridge refuses an edit so dashboards can correlate `document_id`, `tab_id`, `reason`, and whether it was `hash_mismatch`, `chunk_hash_mismatch`, `inspector_failure`, or `retry_exhausted` without duplicating signals.
- [ ] **Hash enforcement plumbing**: Preserve `content_hash`/`chunk_hash` metadata on `PatchRangePayload`/`RangePatch`, compare them to the live document or chunk manifest before applying, and convert any mismatch or `PatchApplyError` raised during range validation into `DocumentVersionMismatchError` so retry logic sees a single, typed failure.
- [ ] **Bridge failure metadata**: Extend `WorkspaceBridgeRouter`/bridge failure listeners to attach `tab_id`, rejection reason, and range stats to both `patch.apply` and `edit_rejected` telemetry payloads before dispatching UI notices, ensuring the chat panel and dashboards see the same cause codes.

## Workstream B — Range-Safe Editing
- [ ] **Range abstraction**: Introduce a `TextRange` dataclass (e.g., `src/tinkerbell/documents/ranges.py`) that can serialize to the existing JSON schema in `tinkerbell/chat/commands.py` so `EditDirective.target_range`, diffs, overlays, and tests speak one format. This becomes the single source of truth once inline actions go away.
- [ ] **Patch-only bridge**: Remove legacy inline action paths from `DocumentEditTool`, `DocumentBridge`, and Search/Replace helpers so every edit is expressed as a diff/range patch that already carries hashes and `TextRange` metadata.
- [ ] **Server-side normalization**: When an edit arrives with raw offsets (including those generated by `SearchReplaceTool`), expand them to the nearest word/paragraph boundaries inside the bridge before applying changes.
- [ ] **Whole-document replace pathway**: Add an explicit `replace_all` or `range="document"` pathway in `DocumentEditTool` so whole-file swaps no longer rely on implicit `(0, len(text))` tuples that bypass validation, and ensure it emits a diff/patch instead of inline content updates.
- [ ] **CRDT/OT compatibility review**: Validate the new `TextRange` plumbing with the undo/redo stack in `EditorWidget` and ensure future CRDT/OT adapters can reuse the same serialization contract.
- [ ] **Schema migration**: Update `DIRECTIVE_SCHEMA`, directive validators, and review/overlay code to emit and accept the new `TextRange` structure while keeping tuple compatibility via adapters during the rollout so existing tools/tests don’t break mid-flight.
- [ ] **Pre-apply normalization**: Move word/paragraph boundary expansion into the diff/range builders (`DocumentApplyPatchTool`, `SearchReplaceTool`, etc.) so the payload reaching the bridge already has aligned `match_text`/hashes; add unit tests that prove widened ranges still validate.

## Workstream C — Duplicate/Corruption Detection
- [ ] **Diff analyzer**: Build a `PostEditInspector` helper (e.g., `src/tinkerbell/editor/post_edit_inspector.py`) that consumes the `pre_edit_snapshot`/`patch_result` already produced by `DocumentBridge`, computes rolling paragraph hashes + token counts, and flags duplicated paragraphs, dropped boundaries, or split tokens.
- [ ] **Auto-revert hook**: Wire the inspector into `DocumentBridge` immediately after the patch/inline edit but before `_notify_listeners`; if it flags anomalies, restore the saved snapshot, emit telemetry, raise `DocumentVersionMismatchError` (or a subclass), and treat the edit as rejected so nothing “mostly applies.”
- [ ] **User feedback**: Extend `ChatPanel`/status UI to display a toast or inline banner (in addition to the existing status-bar message) explaining why an edit was rejected and suggesting a retry.
- [ ] **Config knobs**: Add `safe_ai_edits` thresholds to `src/tinkerbell/services/settings.py`, CLI/env overrides (`TINKERBELL_SAFE_AI_EDITS`, `TINKERBELL_DUPLICATE_THRESHOLD`, `TINKERBELL_TOKEN_DRIFT`), and the Settings dialog so operators can tune inspector sensitivity without code changes. Default to `safe_ai_edits=off`, `duplicate_threshold=2` repeated paragraphs, and `token_drift=0.05` (5%) until QA raises confidence.
- [ ] **Revert contract**: Extend the `EditorAdapter`/`DocumentBridge` contract with a safe rollback path (e.g., reloading the saved snapshot without firing cache events) so the `PostEditInspector` can put the editor back exactly where it started before emitting `edit_rejected` telemetry.
- [ ] **UI signal wiring**: Subscribe `ChatPanel`/status widgets directly to the structured `edit_rejected` payload (tab, reason, inspector diagnostics) so users see the same cause codes as telemetry rather than a generic failure string.

## Workstream D — Testing & Observability
- [ ] **Unit tests**: Extend `tests/test_document_apply_patch.py`, `tests/test_document_edit.py`, `tests/test_bridge.py`, and friends to cover hash rejection, range normalization, inspector failures, and controller retry logic.
- [ ] **Integration tests**: Add pytest-qt flows (in `tests/test_editor_widget.py` or a new `tests/test_safe_ai_edits.py`) that simulate an AI rewrite turn end-to-end, including a forced stale snapshot to ensure the retry path works.
- [ ] **Benchmark scripts**: Update `benchmarks/measure_diff_latency.py` or add a sibling script that times a full `document_apply_patch → bridge.apply` cycle so we can see the overhead from the new guardrails.
- [ ] **Observability plumbing**: Document the telemetry payloads in `docs/ai_v2.md` (and add a new `docs/operations/telemetry.md` section/file) so ingestion pipelines know about `edit_rejected` and inspector events.

- [ ] **Feature flag**: Add a `safe_ai_edits` toggle to `Settings`/`SettingsRuntime`, surface it in the Settings dialog, and honor CLI/env overrides (`TINKERBELL_SAFE_AI_EDITS=1`). Default to off until QA signs off.
- [ ] **Internal dogfood**: Enable the flag for dev builds, collect metrics on rejection/auto-revert counts, and document findings in `docs/ai_v2_release_notes.md`.
- [ ] **Gradual enablement**: When metrics look good, flip the flag on for a subset of users (or make it default-on while leaving an escape hatch) and monitor telemetry for regressions.
- [ ] **Post-launch checklist**: After general availability, archive baseline metrics, close the tracking issue, and update `fixing_ai.md` with the rollout outcome.

## Cross-Cutting Considerations
- Document every new exception/telemetry field in `docs/ai_v2.md` so agent developers know how to respond to guardrail failures.
- Coordinate UI copy with design so warning toasts remain concise and actionable.
- Keep performance in mind: cache paragraph hashes and re-use diffs already computed during edit application to avoid double work.
